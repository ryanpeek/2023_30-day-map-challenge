---
title: '2023 30-day Map Challenge • Day 09 • Hexagons'
author: 'Ryan Peek'
execute:
  echo: false
  warning: false
  message: false
format: 
  html:
    self-contained: true
    code-overflow: wrap
    code-fold: true
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    theme: journal #litera #default
    highlight-style: arrow
editor_options: 
  chunk_output_type: console
---

## Hexagons: Connectivity

30x30 connectivity layer in rayshader style. The 30x30 Areas of Conservation Emphasis (ACE) includes Connectivity. The [Terrestrial Connectivity dataset](https://www.californianature.ca.gov/datasets/CAnature::terrestrial-connectivity-ace/about) summarizes information on terrestrial connectivity by ACE hexagon including the presence of mapped corridors or linkages and the juxtaposition to large, contiguous, natural areas. This dataset was developed to support conservation planning efforts by allowing user to spatially evaluate the relative contribution of an area to terrestrial connectivity based on the results of statewide, regional, and other connectivity analyses.

## Data

```{r}
#| label: the-data
#| message: false
#| warning: false
#| echo: true
#| eval: true

library(tidyverse)
library(hrbrthemes)
library(glue)
library(ggtext)
library(sf)
library(tigris)
library(patchwork)
library(colorspace)
sf::sf_use_s2(FALSE)
library(showtext)
#extrafont::fonts() # get fonts avail
font_add_google("Hepta Slab")
#showtext_auto()

# Get Data ----------------------------------------------------------------

# get an area to crop by
ca <- tigris::states() |> filter(STUSPS=="CA")
cnty <- tigris::counties(state="CA")
# get centroids
cnty_cent <- cnty |> st_centroid() |> 
  st_coordinates() |> as_tibble() |> rename(lon = 1, lat = 2)
cnty_df <- st_drop_geometry(cnty)
cnty_cent <- bind_cols(cnty_cent, cnty_df) |> 
  select(lon,lat, NAME, GEOID)

# plot
ggplot() + 
  geom_sf(data=ca, fill="gray20") +
  geom_sf(data=cnty, fill=NA, color="gray80", lwd=0.4) +
  coord_sf(label_graticule = "")+
  hrbrthemes::theme_ft_rc(base_family = "Hepta Slab")+
  ggrepel::geom_text_repel(data = cnty_cent, 
            aes(x = lon, y = lat, label = NAME), color="white",
            nudge_y = -0.01, min.segment.length = 0.4)+
  labs(x = NULL, y = NULL)

# get 30x30 connectivity data here:
# https://www.californianature.ca.gov/datasets/terrestrial-connectivity-ace/explore
# download a geojson
# https://services2.arcgis.com/Uq9r85Potqm3MfRV/arcgis/rest/services/biosds2734_fpu/FeatureServer
ace_dat <- st_read("data_raw/Terrestrial_Connectivity_-_ACE.geojson")
#st_crs(ace_dat)


```

## Tidy Data

```{r}
#| label: tidy-data
#| message: false
#| warning: false
#| echo: true
#| eval: false

## PLOTTTTTTT
g1 <- ggplot() +
  geom_sf(data= ca, fill=NA, color="gray50", lwd=0.7) +
  geom_sf(data = ace_dat, aes(fill = Connectivity_rank), color=alpha("white",0)) +
  scale_fill_viridis_c("Rank", option="A")+
  hrbrthemes::theme_ft_rc(base_family = "Hepta Slab", plot_title_size = 22,
                          subtitle_size = 16, caption_size = 12)+
  labs(x = NULL, y = NULL) +
  coord_sf(label_axes = "")+
  theme(plot.subtitle = element_text(color="gray80"),
        plot.caption = element_text(color="gray80"),
        legend.text = element_text(color="gray80"),
        plot.background = element_rect("#252a32"),
        legend.position = c(0.1, 0.2),
        panel.grid.major = element_blank())+
  labs(
    title = "Terrestrial Connectivity Ranking",
    subtitle = "#30DayMapChallenge • Day-09 • Hexagons",
    caption="R. Peek • Data: 30x30 <https://www.californianature.ca.gov/> \n <https://github.com/ryanpeek/2023_30-day-map-challenge/>")

g1

g1_nolab <- ggplot() +
  geom_sf(data= ca, fill=NA, color="gray50", lwd=0.7) +
  geom_sf(data = ace_dat, aes(fill = Connectivity_rank), color=alpha("white",0)) +
  scale_fill_viridis_c("Rank", option="A")+
  hrbrthemes::theme_ft_rc(base_family = "Hepta Slab", plot_title_size = 24,
                          subtitle_size = 18, caption_size = 12)+
  labs(x = NULL, y = NULL) +
  coord_sf(label_axes = "")+
  theme(plot.subtitle = element_text(color="gray80"),
        plot.caption = element_text(color="gray80"),
        legend.text = element_text(color="gray80"),
        plot.background = element_rect("#252a32"),
        panel.grid.major = element_blank())+
  labs(
    caption="R. Peek • Data: 30x30 <https://www.californianature.ca.gov/>")

g1_nolab
```

```{r}
#| label: rayshade-prep
#| message: false
#| warning: false
#| echo: true
#| eval: false

bb <- st_bbox(ace_dat)
yind <- st_distance(st_point(c(bb[["xmin"]], bb[["ymin"]])),
                    st_point(c(bb[["xmin"]], bb[["ymax"]])))
xind <- st_distance(st_point(c(bb[["xmin"]], bb[["ymin"]])),
                    st_point(c(bb[["xmax"]], bb[["ymin"]])))

if (yind > xind) {
  y_rat <- 1
  x_rat <- xind / yind
} else {
  x_rat <- 1
  y_rat <- yind / xind
}

size <- 4000 # was 8000
rast <- stars::st_rasterize(ace_dat |>
                       select(Connectivity_rank, geometry),
                     nx = floor(size * x_rat), ny = floor(size * y_rat))


mat <- matrix(rast$Connectivity_rank, nrow = floor(size * x_rat), ncol = floor(size * y_rat))

```

```{r}
#| label: color-palette
#| message: false
#| warning: false
#| echo: false
#| eval: false


# set up color palette
library(rayshader)

#pal <- "hiroshige"
#colors <- met.brewer("Hiroshige", 12)
pal <- "magma"
colors <- viridis::magma(12)
swatchplot(colors)

texture <- grDevices::colorRampPalette(colors[9])(256)
swatchplot(texture)

# render test plot
try(rgl::close3d())

# Create the initial 3D object
mat |>
  height_shade(texture = texture) |>
  plot_3d(heightmap = mat,
          solid = FALSE,
          soliddepth = 0,
          # lower values exaggerate the height
          z = 0.5 / (size / 1000),
          # Set the location of the shadow (the floor)
          # Same scale as your data, set however far below min preferred
          shadowdepth = 0.5,
          # Set window size small, if too big takes longer to build
          windowsize = c(800,800),
          # Phi is azimuth, like the angle of the sun.
          # 90 degrees is directly above, 0 degrees is profile view.
          phi = 90,
          zoom = 1,
          # `theta` is rotation of the map, 0 is north up
          theta = 0,
          background = "#252a32")

# Use this to adjust the view after building the window object
render_camera(phi = 40, fov=40, theta = 340)

```


```{r}
#| label: render-plot
#| message: false
#| warning: false
#| echo: false
#| eval: false

plot_gg(g1_nolab, offset_edges = TRUE,
        width = 8, height = 10, 
        multicore = TRUE, scale = 300, 
        zoom = 1, theta = 340, phi = 40, 
        shadowdepth = -.05,
        windowsize = c(1200, 1200),
        fov = 40, max_error = 0.01, verbose = TRUE, 
        background = "#252a32",)

Sys.sleep(0.2)
render_snapshot(filename = "figs/day09-hexagons_3d.png", 
                background = "#252a32" )

```

```{r}
#| label: render-highqual-plot
#| message: false
#| warning: false
#| echo: false
#| eval: false

# render hi quality?
outfile <- "temp/render.png"

{
  # Test write a PNG to ensure the file path is good.
  # You don't want `render_highquality()` to fail after it's
  # taken hours to render.
  if (!file.exists(outfile)) {
    png::writePNG(matrix(1), outfile)
  }
  # I like to track when I start the render
  start_time <- Sys.time()
  cat(glue("Start Time: {start_time}"), "\n")
  render_highquality(
    # We test-wrote to this file above, so we know it's good
    outfile,
    # See rayrender::render_scene for more info, but best
    # sample method ('sobol') works best with values over 256
    samples = 450,
    preview = FALSE,
    light = TRUE,
    lightdirection = rev(c(230, 230, 225, 225)),
    lightcolor = c(colors[6], "white", colors[10], "white"),
    lightintensity = c(750, 50, 1000, 50),
    lightaltitude = c(10, 80, 10, 80),
    interactive = FALSE,
    # HDR lighting used to light the scene
    # environment_light = "assets/env/phalzer_forest_01_4k.hdr",
    # # environment_light = "assets/env/small_rural_road_4k.hdr",
    # # Adjust this value to brighten or darken lighting
    # intensity_env = 1.5,
    # # Rotate the light -- positive values move it counter-clockwise
    # rotate_env = 130,
    # This effectively sets the resolution of the final graphic,
    # because you increase the number of pixels here.
    # width = round(6000 * wr), height = round(6000 * hr),
    width = 4000, height = 4000,
    ground_material = rayrender::diffuse(color = colors[12])
  )
  end_time <- Sys.time()
  cat(glue("Total time: {end_time - start_time}"), "\n")
}
```

```{r}
#| label: label-plot
#| message: false
#| warning: false
#| echo: false
#| eval: true

library(magick)
library(glue)
library(colorspace)

colors <- met.brewer("Hiroshige", 12)
swatchplot(colors)
text_color <- colors[5]

## Read in Image ---------------
img <- image_read("temp/render.png")
image_info(img)

s <- darken("#9a9397", .1)
shadow <- "#9a9397"
inset <- image_read("images/30x30_White.png")

## Add Stuff to Image and Write Out ------------------------------------------------------

img |>
  image_crop(geometry = "3000x2000+0+0", gravity = "center") |>
  image_annotate(text = "CA", degrees = 350, 
                 gravity = "north",
                 location = "+100+500", font = "Go Mono for Powerline",
                 color = text_color, kerning = 20,
                 size = 200, weight = 500) |> 
  image_composite(image_scale(inset, geometry = "25%x"),
                   gravity = "southwest",
                   offset = "+1000+100") |>
  image_write("temp/titled.png")

```

```{r}
#| label: patchwork-plot
#| message: false
#| warning: false
#| echo: false
#| eval: false

library(patchwork)
my_img <- image_read("temp/titled.png") |> 
  image_crop(geometry = "3000x2000+100+100", gravity = "center")
my_img

image_info(my_img)  

# alt
my_image <-  png::readPNG("temp/titled.png")
library(cropcircles)
img_circle <- circle_crop("temp/titled.png", "temp/titled_circle.png", border_size = 200, border_colour = "#252a32")
circ_image <-  png::readPNG("temp/titled_circle.png")

# standard
gall <- g1 + grid::rasterGrob(circ_image) + 
  theme(plot.background = element_rect(fill = "#252a32", 
                                       colour = "#252a32"))
gall
ggsave(filename = glue("figs/day09_hexagons_3d_circle_v1.png"), width = 11, height = 8.5, dpi = 300)


# inset
ginset <- g1 + patchwork::inset_element(grid::rasterGrob(my_img), 0.7, 0.2, 1, 1, clip = FALSE) & theme(plot.background = element_rect(fill = "#252a32", colour = "#252a32"))
gall

ggsave(filename = glue("figs/day09_hexagons_3d.png"), width = 11, height = 8.5, dpi = 300)





gall <- g1 + grid::rasterGrob(circ_image) + 
  theme(plot.background = element_rect(fill = "#252a32", 
                                       colour = "#252a32"))
gall
ggsave(filename = glue("figs/day09_hexagons_3d_circle_v1.png"), width = 11, height = 8.5, dpi = 300)


# inset
ginset <- g1 + patchwork::inset_element(grid::rasterGrob(my_img), 0.7, 0.2, 1, 1, clip = FALSE) & theme(plot.background = element_rect(fill = "#252a32", colour = "#252a32"))
gall

ggsave(filename = glue("figs/day09_hexagons_3d.png"), width = 11, height = 8.5, dpi = 300)


```

